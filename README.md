# Predicate1
Предикаты
1) В нашем предыдущем примере мы создали интерфейс с одним методом:

boolean test(Animal a);
Лямбды работают с интерфейсами, которые имеют только один метод.
Это так называемые функциональные интерфейсы - интерфейсы, которые можно использовать с функциональным программированием. 
(На самом деле это сложнее, чем это, но для экзамена ОСА это определение подходит.)
Вы можете себе представить, что нам нужно было бы создать множество таких интерфейсов, чтобы использовать лямбды.
Мы хотим проверить Animals и Strings и Plants и все остальное, с чем мы сталкиваемся.
К счастью, Java признает, что это распространенная проблема, и предоставляет нам такой интерфейс. Это в упаковке, java.util.functionи суть этого заключается в следующем:

public interface Predicate<T> {
  boolean test(T t);
}
Это очень похоже на наш метод. Разница лишь в том, что он использует этот тип Tвместо Animal. Это синтаксис для дженериков.
Это как когда мы создали ArrayListи должны указать любой тип, который входит в него
.Это означает, что нам больше не нужен наш собственный интерфейс, и мы можем поместить все, что связано с нашим поиском, в один класс:

1: import java.util.*;
2: import java.util.function.*;
3: public class PredicateSearch {
4:   public static void main(String[] args) {
5:     List<Animal> animals = new ArrayList<Animal>();
6:     animals.add(new Animal("fish", false, true));
7:
8:     print(animals, a -> a.canHop());
9:   }
10:  private static void print(List<Animal> animals, Predicate<Animal> checker) {
11:    for (Animal animal : animals) {
12:      if (checker.test(animal))
13:         System.out.print(animal + " ");
14:     }
15:     System.out.println();
16:  }
17: }
На этот раз изменилась только строка 10. Мы ожидаем, Predicateчто передадим этот тип использует Animal. Довольно круто.
Мы можем просто использовать его без необходимости писать дополнительный код.
Java 8 даже интегрировал Predicateинтерфейс в некоторые существующие класcы

2)предыдущий пример  

В этом разделе мы рассмотрим пример того, почему полезны лямбды, синтаксис лямбд 

Лямбда Пример

Наша цель - распечатать всех животных в списке в соответствии с некоторыми критериями. Мы покажем вам, как это сделать без лямбд, 
чтобы проиллюстрировать, как они полезны. Мы начинаем с Animalкласса:
public class Animal { 
 private String species;
  private boolean canHop;  
private boolean canSwim;  
public Animal(String speciesName, boolean hopper, boolean swimmer) {   
 species = speciesName;   
 canHop = hopper;    
canSwim = swimmer; 
 }  
 public boolean canHop() { return canHop; }   
public boolean canSwim() { return canSwim; }
   public String toString() { return species; 
}}
У Animalкласса есть три переменных экземпляра, которые задаются в конструкторе. У него есть два метода, позволяющие определить,
может ли животное прыгать или плавать. У этого также есть toString()метод, таким образом, мы можем легко идентифицировать Animalв программах.
Мы планируем написать много разных проверок, поэтому нам нужен интерфейс. Вы узнаете больше об интерфейсах в следующей главе.
Пока достаточно вспомнить, что интерфейс определяет методы, которые должен реализовать наш класс:


public interface CheckTrait {
  boolean test(Animal a);
}
Первое, что мы хотим проверить - может ли Animalхоп прыгнуть. Мы предоставляем класс, который может проверить это:

public class CheckIfHopper implements CheckTrait { 
 public boolean test(Animal a) { 
   return a.canHop(); 
 }}
Этот класс может показаться простым - и это так. На самом деле это часть проблемы, которую решают лямбды. Просто потерпи немного. 
Теперь у нас есть все, что нам нужно, чтобы написать наш код, чтобы найти те, Animalкоторые прыгают:

1: public class TraditionalSearch {
2:   public static void main(String[] args) {
3:     List<Animal> animals = new ArrayList<Animal>();  // list of animals
4:     animals.add(new Animal("fish", false, true));
5:     animals.add(new Animal("kangaroo", true, false));
6:     animals.add(new Animal("rabbit", true, false));
7:     animals.add(new Animal("turtle", false, true));
8:
9:     print(animals, new CheckIfHopper());      // pass class that does check
10:   }
11:  private static void print(List<Animal> animals, CheckTrait checker) {
12:     for (Animal animal : animals) {
13:       if (checker.test(animal))               // the general check
14:         System.out.print(animal + " ");
15:     }
16:     System.out.println();
17:   }
18: }
print()Способ по линии 11 метода очень общий может проверить любой признак. Это хороший дизайн. Не нужно знать, что именно мы ищем, чтобы напечатать список животных.
Теперь, что произойдет, если мы хотим напечатать Animals, которые плавают? Вздох. Нам нужно написать еще один класс CheckIfSwims.
Конечно, это всего лишь несколько строк. Затем нам нужно добавить новую строку в строке 9, которая создает экземпляр этого класса. 
Это две вещи, просто чтобы сделать еще одну проверку.
Почему мы не можем просто указать логику, о которой мы заботимся прямо здесь? Оказывается, что мы можем с лямбда-выражениями.
Мы могли бы повторить весь этот класс здесь и заставить вас найти одну строку, которая изменилась. Вместо этого мы просто покажем вам.
Мы могли бы заменить строку 9 следующей строкой, которая использует лямбду:


9:    print(animals, a -> a.canHop());

Не беспокойтесь, что синтаксис выглядит немного прикольным. Вы привыкнете к этому, и мы опишем это в следующем разделе. 
Мы также объясним биты, которые выглядят как волшебство. А пока просто сосредоточьтесь на том, как легко читать. 
Мы говорим Java, что нам важны только те, Animalкоторые могут прыгать.
Не нужно много воображения, чтобы понять, как мы добавим логику, чтобы получить те, Animalкоторые могут плавать.
Нам нужно только добавить одну строку кода - не нужно дополнительного класса, чтобы сделать что-то простое. Вот эта другая строка:

print(animals, a -> a.canSwim());
Как насчет того, Animalчто не умеет плавать?

print(animals, a -> ! a.canSwim());
Дело в том, что действительно легко написать код, который использует лямбды, как только вы освоите основы.
Этот код использует концепцию, называемую отложенным выполнением. Отложенное выполнение означает, что код указан сейчас, но будет выполняться позже.
В этом случае позже, когда print()метод вызывает его.

3)Лямбда-синтаксис

Одно из самых простых лямбда-выражений, которое вы можете написать, это то, которое вы только что видели:

a -> a.canHop();

Это означает, что Java должна вызывать метод с Animalпараметром, который возвращает booleanзначение, результатом которого является a.canHop().
Мы знаем все это, потому что мы написали код. Но как Java знает?
Java отвечает на контекст, выясняя, что означают лямбда-выражения. Мы передаем эту лямбду как второй параметр print()метода.
Этот метод ожидает в CheckTraitкачестве второго параметра. Поскольку вместо этого мы передаем лямбду, Java пытается отобразить нашу лямбду на этот интерфейс:

boolean test(Animal a);
Так как метод этого интерфейса принимает Animal, это означает, что лямбда-параметр должен быть Animal.
И поскольку метод этого интерфейса возвращает a boolean, мы знаем, что лямбда-выражение возвращает a boolean.
Синтаксис лямбды сложен, потому что многие части являются необязательными. Эти две строки делают одно и то же:


a -> a.canHop()
(Animal a) -> { return a.canHop();
 }
Давайте посмотрим, что здесь происходит. Первый пример, показанный на рисунке 4.5 , состоит из трех частей:
•	Укажите один параметр с именем a
•	Оператор стрелки для разделения параметра и тела
•	Тело, которое вызывает один метод и возвращает результат этого метода
Рисунок 4.5 Лямбда-синтаксис, пропускающий необязательные части
Второй пример также состоит из трех частей; это просто более многословно (см. рисунок 4.6 ):
•	Укажите один параметр с именем aи указав типAnimal
•	Оператор стрелки для разделения параметра и тела
•	Тело, содержащее одну или несколько строк кода, включая точку с запятой и оператор возврата
Рисунок 4.6 Лямбда-синтаксис, включая дополнительные части
Скобки могут быть опущены, только если есть один параметр, а его тип явно не указан.
Java делает это, потому что разработчики обычно используют лямбда-выражения таким образом, и они могут печатать как можно меньше.
Для вас не должно быть новостью, что мы можем опустить скобки, когда у нас есть только одно утверждение.
Мы сделали это с ifзаявлениями и циклами уже. Что здесь отличается, так это то, что правила меняются, когда вы опускаете скобки.
Java не требует от вас вводить returnили использовать точку с запятой, когда не используются скобки.
Этот специальный ярлык не работает, когда у нас есть два или более операторов. По крайней мере, это согласуется с использованием {}для создания блоков кода в другом месте.
Давайте посмотрим на некоторые примеры действительных лямбд. Представьте, 
что существуют допустимые интерфейсы, которые могут использовать лямбду с нулевым, одним или двумя Stringпараметрами.
3: print(() -> true);                                       // 0 parameters
4: print(a -> a.startsWith("test"));                        // 1 parameter
5: print((String a) -> a.startsWith("test"));               // 1 parameter
6: print((a, b) -> a.startsWith("test"));                   // 2 parameters
7: print((String a, String b) -> a.startsWith("test"));     // 2 parameters
Обратите внимание, что все эти примеры имеют круглые скобки вокруг списка параметров, кроме того, который принимает только один параметр и не указывает тип.
Строка 3 принимает 0 параметров и всегда возвращает логическое значение true. Строка 4 принимает один параметр и вызывает для него метод, возвращая результат.
Строка 5 делает то же самое, за исключением того, что она явно определяет тип переменной.
Строки 6 и 7 принимают два параметра и игнорируют один из них - не существует правила,
которое говорит, что вы должны использовать все определенные параметры.
Теперь давайте удостоверимся, что вы можете определить неверный синтаксис. Вы видите, что не так с каждым из них?


print(a, b -> a.startsWith("test"));                       // DOES NOT COMPILE
print(a -> { a.startsWith("test"); });               // DOES NOT COMPILE
print(a -> { return a.startsWith("test") });         // DOES NOT COMPILE
Первая строка требует скобок вокруг списка параметров. Помните, что круглые скобки являются необязательными, только когда есть один параметр,
и у него нет объявленного типа. Во второй строке отсутствует returnключевое слово. В последней строке пропущена точка с запятой.
Вы могли заметить, что все наши лямбды возвращаются boolean. Это связано с тем, что рамки экзамена OCA ограничивают то, что вам необходимо изучить.
Какие переменные могут иметь доступ к моей лямбда?
Лямбдам разрешен доступ к переменным. Эта тема не относится к экзамену ОСА, но вы можете столкнуться с ним во время практики.
Лямбдам разрешен доступ к переменным. Вот пример:

boolean wantWhetherCanHop = true;
print(animals, a -> a.canHop() == wantWhetherCanHop);
Хитрость в том, что они не могут получить доступ ко всем переменным. Экземпляр и статические переменные в порядке.
Параметры метода и локальные переменные хороши, если им не назначены новые значения.
Есть еще одна проблема, которую вы можете увидеть с лямбдами. Мы определяли список аргументов в наших лямбда-выражениях.
Поскольку Java не позволяет нам переопределить локальную переменную, проблема заключается в следующем:

boolean wantWhetherCanHop = true;
print(animals, a -> a.canHop() == wantWhetherCanHop);
Мы пытались переопределить a, что не разрешено. Напротив, следующая строка в порядке, потому что она использует другое имя переменной:

(a, b) -> { int a = 0; return 5;}     // DOES NOT COMPILE


(a, b) -> { int c = 0; return 5;}



